MASTERING BTC NTS

Auth: Mohammad Jabeen

Purpose: This is an overall notes section on the bitcoin, including the full system from wallets, transactions, blocks, mining etc. Based on the book Mastering bitcoin by Andreas M Antonpoulos

Transaction ledger - The blockchain

Bitcoin is a fully distributed peer to peer system, with no real coins instead value is implied via signed (for auth - stop counterfiet) transactions.

The bitcoin protocol stack is open source and the protcol communicated via the internet. 

Currency issused via mining at fixed rate with 4 year halfing leading to cap of 21 million by 2140!!

HISTORY

2008 - white paper released by satoshi nakaomoto
2009 - bitcoin network started

CLIENTS

 - Full Index Node (controls full protocol and holds backup of all transaction)
 - Light (controls wallets, relies on servers for tranasction and network)
 - Web (Holds nothing, acts as api to servers for protocols) - use GRPC API to gather unspent transactions

TRUSTED TRANSACTION

Blockchain explorer - Search engine for tranas using an address

Tranasctions are made from inputs that contain the prev tranasction which was encumbered
The output will be encumbered by using the receivers pub key so that only they can use it via signature

An output will contain change back to the sender if the input doesnt match the payment amount
Inputs are combined and can be to multiple outputs if required

When sent to the network all nodes (in the peer-peer network) will forward to other nodes any transaction the recieve, within a few seconds the client will recieve from the send the transaction

Clients can be confident if the transaction uses unspent prev transaction and enough transaction fee to be mined

Output != Input //Delta is transaction fee

When a new block is mined the fingerprint of the previous block is used 
When the solution is found the transaction is added to the blockchain
After 6 Blocks ontop considered trusted (irrevocable) and irreverable due to comp required for reversal

Full client will check entire transaction history back to mined coin
Light client will be based on check if its in the blockchain and has blocks ontop


THE BITCOIN CLINET (bitcoind , the satoshi client)

btcd - go client

interesting side mission -------

Eliptical curve crypto (ECC)

Trapdoor func - Math func A->B easy | B->A very hard
ECC much more secure for the same storage size ie 256 bit 

Eliptic curve - symmetric on the x axis and 3 intercepts on any straight line
Priv = (n dot^n)

384 - military safe 

bitcoin uses spec256k1
y^2 = (x^3 + 7) over F_p(modulo prime number p)
---------------

private key (random 256 bit number) -> pub key (Crypto func (elliptic) -> Address (Hash)

pub key -> Address is SHA256 has then RIPEMD160 Hash ends with 160 bit number
pub key - prefix + x coor + y coor

Base58Check Encoding (WIF) Wallet import format

Encoded in base58 without 0OlI, with checksum (double hash added to end) to avoid human mistakes

To save data compressed pub keys omit y (cacl using eq) but need a specific prefix to show odd or even (02 even 03 odd)
priv key compressed (WIF-compressed) outputs compressed pub key and address, priv key uncompressed(WIF) does not

Seeded wallets or determinstic use a seed and hash to generate the priv key. (non determinstic use a bunch of random priv keys)
Mnemonic code words - Seed can be generated from a bunch of words.

Child keys made from a hash of parent pub/priv key, chain code and index number.
The chain code adds randomness so a child cant be used to find another child only on its index.

HD wallets allow easy tracing of pub keys to childs but seperate out the priv key, good for ecommerce (customer needs pub key) server.

Extended key - Comb pub key and chain code

HD wallets issue leaked child priv key makes the master key vunerable
Use hardened child key (made from priv key in hash not pub)

BIP0043 and BIP0044 - standards for HD wallet structure

standard btc address starts with 1
P2SH pay to script hash instead uses a script to create the address, encumbering payments to that address with the script. ie used for multi sig proof before use of a transaction.

Vanity address - chosen words in address calculated using brute force

UTXO - Unspent transaction output

Fees calculated based on transaction memory size

If child trans received before parent then stored in temp orphan pool with set number of max stored childs allowed

Script language (turing incompletness and statless (very portable)) simple for security uses stacks (pop and push)

Process is unlock script output -> lock script

5 standards P2PKH (compares pub key hash then checks sig)
- P2PK (crappy P2PKH)
- OP_return (store unspendable data 40 bytes)
- P2SH (compare script hash, then run script) uses script hash as address


THE BITCOIN NETWORK

Uses the bitcoin P2P protocol, other protcols can communicate to the network via the btc P2P protocol

Pool protocol servers act as gateways to "bridge" between the btc P2P protocol and others such as Stratum

On start up of a client it will noramlly use seeded other peers to gather the required data (can use specified ip of another peer)

Will then setup connection to a number of peers
- During the blockchain download the number of blocks transimtted is limited to not overwhelm the network

Simple Payment Verifaction nodes (SPV) lightweight mobile nodes, check if the transaction is 6 blocks deep to verify transaction, full node would use a full check of the blockchain.

SPV only keep track of block headers and (want to know) the transactions they care about. IE thier address related - causes privacy issue if watched.

To protect from privacy issue use Bloom filters (use hash and array) to make transaction pattern that will match the wanted trans and a other random ones. It is a probabalistic search filter, the more hashes it uses or the smaller the array the less accurate but better privacy.

Transaction pools held in every node to hold all unconfirmed trans, each node verifies it then adds to pool. Also orphan pools for trans where the parent hasnt been received this could be a long chain triggered to move into trans pool if the head parents is received.

Alert messages only usable by a few core devs (priv key holder) to show a serious blockchain issue

THE BLOCKCHAIN

An ordered back linked-list of blocks

A block can have only one parent but may have muliptle children

Each block is identified by its hash and will contain the previous blocks hash in the header

As the previous blocks hash is used to create the current blocks hash, changing any block will require subsequent changes in blocks

The blocks structure is made 80 bytes of header (4 B of block size, 1-9 Bytes of Transaction counter) and then (average ~ 250B) transactions 

The header includes : Software Version, Previous block hash, merkle root, timestamp, Difficulty target, nonce / 6 things

A blocks hash is the the block header hashed twice

The gensis blocks is stored statically in the client code as a reference point

Verify blocks by comparing prev hash to the prev block in the chain

Merkle trees is a binary hash tree which conatins as leafs pairs of transactions hashed (double hashed) and the resulted hashing paired and hashed till only one root leaf

Used to validate transactions by validating the tree path in a node, at worst O = 2log(N)

Simplified Payment Verfication (SPV) will ask for a merkle path and header within a merkle block message, this will allow the SPV to validate the block and if the transaction is in the block

It does this by calculating and valdiating the root leaf using the path and the transaction.

MINING

A new block is mined apporox every 10 mins, with an adjusting Difficulty to keep this level

Minings main function is to secure the bitcoin network to fraudlent transactions and provide a secure method of consensus

It also incentivies this function by providing newcoins, this coin amount is halfed every 4 years or 210,000 blocks (started at 50 blocks)

Also transaction fees are collected by miners

Miners competete to solve a mathematical problem of producing a hash lower than a threshold for a givin block header

From this competition emereges a conseus mechanism that keeps a consistent track of the current state of the blockchain secure to attacks, called Proof of work

Decentrailised consensus arises from four processes:
    - Verfication of each tranasction
    - Aggregrate transactions into a new block verifed via proof of work
    - Verify new blocks by every node and assembly
    - Selection of every chain with the most cumulative computation (through Proof of work)

Due to the independant verification of each transaction before relay, all nodes build a pool of valid tranasction in roughly the same order

Tranasctions are prioritised and the highest priorty transactions are first into the block

Priorty = Sum (Value of input * Input age) / Transaction Size

Age of UTXO is the blocks elapsed since the UTXO was recorded

First 50 kilobytes of the block are used for high priorty transactions, the rest is prioritised based fee per kb of transaction

Bitcoin transactions do not have an expiration timeout they will remain in any nodes unsusued transaction pool until restarted

The first transaction added to the block is called the generation transaction, it is the miners reward for mining (new block amount + tranasction fee) 

This transaction does not use a UTXO as an input instead uses coinbase

A generation transaction has no unlocking script, and the transaction hash and output index are set to 0 and 1 respectively

There is also a coinbase data field in the generation transaction, which includes a push operation with the block height and an extra nonce

Example Difficulty Target:
    - Ox00001601677C5806

The difficulty is normally represented in coefficent exponent form (target = coefficent * 2^(8*(exponent-3)))

The difficulty is calculated by comparing the time take to mine the last 2016 blocks and 20160 minutes

The maximum the difficulty can be altered in one go is a factor of four to avoid voltailty

If there is a fork the chain with the most cumulative difficulty will be chosen as the main chain (ie the chain with the most blocks)

Forks occur if block solutions are found at similar time and the may diverge on the main chain, this will be solved most likley by the next block (whichever chain finds the next block first) as it will be distributed and chosen as the chain with the most difficulty

Miner hashing tech has boomed from CPU to GPU to FPGA to ASICs

Mining pools combine the effort of a number miners to and then share the rewareds between them based on hash provided by each miner

Pools use 'shares' which is roughly 1000x easier than the difficulty target, to measure miner contribution

Pools are generally managed and connected to a full node to construct the new block, but centrealised :( 
    
P2Pool is a decentrailsied version using a sharechain to keep track of miner contribution and reward miners

A consensus attack is when a large group of miners attack the consensus mechanism on deciding the new chain or block

A consensus attack will allow double spending or denail of service, by forking off the chain and creating enough blocks to shift the new chain to the main chain

A method to aleviate risk of double spends is using a multi sig account

BITCOIN SECURITY

Bitcoin require no user vetting or encryption, the information can be sent via any public channel

Bitcoin is not vunerable to mass comproise as there is storage of user keys outside the user

Traditional security architecture is based on root of trust, generally software build around this root of trust

The gensis block is the root of trust and a fully validated blockchain can be trusted